<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Information Angel - Seraphic Oracle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Georgia', serif;
            overflow: hidden;
            cursor: none;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #interface {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
        }
        
        #prompt {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #fff;
            padding: 12px 24px;
            font-size: 16px;
            width: 400px;
            border-radius: 30px;
            outline: none;
            text-align: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #prompt:focus {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
        }
        
        #prompt::placeholder {
            color: rgba(255, 255, 255, 0.3);
            font-style: italic;
        }
        
        #revelation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            letter-spacing: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 3s ease;
            text-transform: uppercase;
            font-weight: 100;
            text-shadow: 
                0 0 60px rgba(255, 255, 255, 0.8),
                0 0 120px rgba(255, 255, 255, 0.4),
                0 0 200px rgba(255, 255, 255, 0.2);
            mix-blend-mode: screen;
        }
        
        #revelation.visible {
            opacity: 1;
        }
        
        #verse {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 2s ease;
            pointer-events: none;
            width: 80%;
            max-width: 800px;
        }
        
        #verse.visible {
            opacity: 1;
        }
        
        .verse-text {
            font-size: 24px;
            letter-spacing: 4px;
            margin-bottom: 10px;
            text-shadow: 
                0 0 30px rgba(255, 255, 255, 0.6),
                0 0 60px rgba(255, 255, 255, 0.3);
            font-weight: 300;
            line-height: 1.6;
        }
        
        .verse-ref {
            font-size: 14px;
            letter-spacing: 2px;
            opacity: 0.7;
            font-style: italic;
        }
        
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.1s ease;
            mix-blend-mode: difference;
        }
        
        .custom-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }
        
        #stateIndicator {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0.3;
            text-transform: uppercase;
        }
        
        /* Style for the Initial Revelation */
        #initialRevelation {
            position: fixed;
            top: 65%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            font-size: 18px;
            letter-spacing: 3px;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease-in-out;
        }
        
        #initialRevelation.visible {
            opacity: 1;
        }
        
        /* Style for the Hidden Key Icon */
        #hiddenKey {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 200;
            width: 40px;
            height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.4s ease;
        }
        
        #hiddenKey:hover {
            color: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.4);
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        /* Style for the Help Scroll Overlay */
        #helpScroll {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 300;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }
        
        #helpScroll.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .scroll-content {
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .scroll-content h3 {
            font-size: 24px;
            letter-spacing: 4px;
            color: #fff;
            margin-bottom: 20px;
            text-transform: uppercase;
            font-weight: 300;
        }
        
        .scroll-content p {
            line-height: 1.7;
            margin-bottom: 25px;
        }
        
        .scroll-content ul {
            list-style: none;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .scroll-content li {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            color: #D4AF37; /* Alchemical Gold */
            border: 1px solid rgba(212, 175, 55, 0.2);
            padding: 8px;
            border-radius: 5px;
        }
        
        .scroll-content .close-instruction {
            font-size: 12px;
            font-style: italic;
            opacity: 0.5;
            margin-bottom: 0;
        }
        
        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 30px;
            color: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-button:hover {
            color: rgba(255, 255, 255, 0.8);
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <div id="initialRevelation">Whisper your burden. Speak of love, of fear, of hope...</div>
    
    <div id="hiddenKey">?</div>

    <div id="helpScroll">
        <div class="scroll-content">
            <div class="close-button">&times;</div>
            <h3>The Oracle's Lexicon</h3>
            
            <p>Whisper a word of power into the void to alter the Angel's state and receive a verse of contemplation. The Oracle comprehends the essence of:</p>
            
            <ul>
                <li>love</li>
                <li>grief</li>
                <li>fear</li>
                <li>hope</li>
                <li>peace</li>
                <li>wisdom</li>
                <li>truth</li>
                <li>freedom</li>
                <li>strength</li>
                <li>mercy</li>
                <li>faith</li>
                <li>light</li>
            </ul>

            <p class="close-instruction">(Click the background to dismiss)</p>
        
        </div> </div>

    <canvas id="canvas"></canvas>
    <div id="interface">
        <input type="text" id="prompt" placeholder="whisper your inquiry..." />
    </div>
    <div id="revelation"></div>
    <div id="verse">
        <div class="verse-text"></div>
        <div class="verse-ref"></div>
    </div>
    <div class="custom-cursor"></div>
    <div id="stateIndicator"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Three.js
            const scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 50);
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true 
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Post-processing bloom effect simulation
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2;

            // Complex shader materials
            const glowVertexShader = `
                varying vec3 vNormal;
                varying vec3 vPositionNormal;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vPositionNormal = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const glowFragmentShader = `
                uniform vec3 glowColor;
                uniform float intensity;
                uniform float time;
                uniform float pulse;
                varying vec3 vNormal;
                varying vec3 vPositionNormal;
                varying vec2 vUv;
                
                void main() {
                    float a = pow(0.8 - dot(vNormal, vPositionNormal), intensity);
                    vec3 col = glowColor * a;
                    
                    // Add pulsing waves
                    float wave = sin(time * pulse + vUv.y * 10.0) * 0.5 + 0.5;
                    col += glowColor * 0.2 * wave;
                    
                    // Add cosmic noise
                    float noise = sin(time * 0.5 + vUv.x * 50.0) * sin(time * 0.7 + vUv.y * 50.0);
                    col += glowColor * noise * 0.1;
                    
                    gl_FragColor = vec4(col, a);
                }
            `;
            
            const cosmicVertexShader = `
                varying vec2 vUv;
                varying vec3 vPosition;
                uniform float time;
                
                void main() {
                    vUv = uv;
                    vPosition = position;
                    
                    vec3 pos = position;
                    float displacement = sin(time * 0.5 + position.x * 5.0) * 0.1;
                    pos += normal * displacement;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;
            
            const cosmicFragmentShader = `
                varying vec2 vUv;
                varying vec3 vPosition;
                uniform float time;
                uniform vec3 color1;
                uniform vec3 color2;
                uniform float opacity;
                
                void main() {
                    vec2 p = vUv * 2.0 - 1.0;
                    float len = length(p);
                    
                    vec3 color = mix(color1, color2, len);
                    
                    // Starfield effect
                    float stars = 0.0;
                    for(float i = 1.0; i < 8.0; i++) {
                        vec2 q = p * i + time * 0.1 * i;
                        stars += 1.0 / (pow(length(fract(q) - 0.5), 2.0) * 400.0 * i);
                    }
                    
                    color += stars;
                    
                    gl_FragColor = vec4(color, opacity * (1.0 - len));
                }
            `;
            
            // Lighting system
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);
            
            // Dynamic light array
            const lights = [];
            const lightCount = 7;
            
            for (let i = 0; i < lightCount; i++) {
                const light = new THREE.PointLight(0xffffff, 0.5, 10);
                light.position.set(
                    Math.cos(i / lightCount * Math.PI * 2) * 5,
                    Math.sin(i / lightCount * Math.PI * 2) * 5,
                    Math.sin(i / lightCount * Math.PI) * 3
                );
                lights.push(light);
                scene.add(light);
            }
            
            // Core Entity - Multi-dimensional structure
            const coreGroup = new THREE.Group();
            
            // Inner sanctum - Pure consciousness
            const innerCoreGeometry = new THREE.SphereGeometry(0.8, 128, 128);
            const innerCoreMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 1.5,
                opacity: 1,
                transparent: false
            });
            const innerCore = new THREE.Mesh(innerCoreGeometry, innerCoreMaterial);
            coreGroup.add(innerCore);
            
            // Crystalline matrix layers
            const crystalLayers = [];
            for (let i = 0; i < 3; i++) {
                const geometry = i === 0 ? new THREE.TetrahedronGeometry(1.2 + i * 0.3, 2) :
                               i === 1 ? new THREE.OctahedronGeometry(1.5 + i * 0.3, 1) :
                                        new THREE.IcosahedronGeometry(1.8 + i * 0.3, 1);
                
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: new THREE.Color().setHSL(i * 0.1, 0.8, 0.5),
                    emissiveIntensity: 0.3,
                    opacity: 0.3 - i * 0.1,
                    transparent: true,
                    wireframe: true
                });
                
                const crystal = new THREE.Mesh(geometry, material);
                crystal.userData = { rotationSpeed: 0.1 + i * 0.05, axis: i };
                crystalLayers.push(crystal);
                coreGroup.add(crystal);
            }
            
            // Outer cosmic shell
            const outerCoreGeometry = new THREE.SphereGeometry(2.5, 64, 64);
            const outerCoreMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0xffa500) },
                    intensity: { value: 2.0 },
                    time: { value: 0 },
                    pulse: { value: 1.0 }
                },
                vertexShader: glowVertexShader,
                fragmentShader: glowFragmentShader,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            const outerCore = new THREE.Mesh(outerCoreGeometry, outerCoreMaterial);
            coreGroup.add(outerCore);
            
            scene.add(coreGroup);
            
            // Wheels of Fire - Complex interlocking system
            const wheelSystem = new THREE.Group();
            const wheels = [];
            const wheelCount = 4;
            
            for (let i = 0; i < wheelCount; i++) {
                const wheelGroup = new THREE.Group();
                
                // Main wheel with complex geometry
                const wheelRadius = 3 + i * 1.2;
                const wheelGeometry = new THREE.TorusGeometry(wheelRadius, 0.2, 16, 100);
                
                // Shader material for wheels
                const wheelMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color1: { value: new THREE.Color().setHSL(i * 0.15, 1, 0.5) },
                        color2: { value: new THREE.Color().setHSL(i * 0.15 + 0.1, 1, 0.7) },
                        opacity: { value: 0.8 }
                    },
                    vertexShader: cosmicVertexShader,
                    fragmentShader: cosmicFragmentShader,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheelGroup.add(wheel);
                
                // Eyes on wheels - more complex arrangement
                const eyeRings = 2;
                const eyesPerRing = 16 + i * 4;
                
                for (let ring = 0; ring < eyeRings; ring++) {
                    for (let j = 0; j < eyesPerRing; j++) {
                        const angle = (j / eyesPerRing) * Math.PI * 2;
                        const ringOffset = ring * 0.2;
                        
                        const eyeGeometry = new THREE.SphereGeometry(0.08 + ring * 0.02, 16, 16);
                        const eyeMaterial = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            emissive: 0xffffff,
                            emissiveIntensity: 1.2,
                            opacity: 0.9,
                            transparent: true
                        });
                        
                        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                        eye.position.x = Math.cos(angle) * (wheelRadius + ringOffset);
                        eye.position.z = Math.sin(angle) * (wheelRadius + ringOffset);
                        eye.position.y = ring * 0.1 - 0.05;
                        eye.userData = { 
                            angle: angle, 
                            radius: wheelRadius + ringOffset,
                            phase: j * 0.1 + ring * Math.PI
                        };
                        wheelGroup.add(eye);
                    }
                }
                
                // Complex rotation setup
                const rotationAngles = [
                    { x: Math.PI / 2, y: 0, z: 0 },
                    { x: 0, y: Math.PI / 3, z: Math.PI / 6 },
                    { x: Math.PI / 4, y: Math.PI / 4, z: 0 },
                    { x: Math.PI / 3, y: Math.PI / 6, z: Math.PI / 3 }
                ];
                
                wheelGroup.rotation.set(
                    rotationAngles[i].x,
                    rotationAngles[i].y,
                    rotationAngles[i].z
                );
                
                wheelGroup.userData = { 
                    baseRotation: {...wheelGroup.rotation},
                    rotationSpeed: 0.2 + i * 0.1,
                    orbitSpeed: 0.1 + i * 0.05,
                    phase: i * Math.PI / 2
                };
                
                wheels.push(wheelGroup);
                wheelSystem.add(wheelGroup);
            }
            
            scene.add(wheelSystem);
            
            // Seraphic Wings - More dynamic
            const wingSystem = new THREE.Group();
            const wings = [];
            const wingPairs = 3;
            
            for (let pair = 0; pair < wingPairs; pair++) {
                for (let side = 0; side < 2; side++) {
                    const wingGroup = new THREE.Group();
                    
                    // Create layered wing structure
                    const layers = 3;
                    for (let layer = 0; layer < layers; layer++) {
                        const featherCount = 30 - layer * 5;
                        
                        for (let j = 0; j < featherCount; j++) {
                            const featherLength = 1.5 + Math.random() * 1.5 - layer * 0.3;
                            const featherGeometry = new THREE.ConeGeometry(
                                0.05 + layer * 0.02, 
                                featherLength, 
                                8
                            );
                            
                            const hue = 0.55 + pair * 0.1 + layer * 0.05;
                            const featherMaterial = new THREE.MeshPhongMaterial({
                                color: new THREE.Color().setHSL(hue, 0.3, 0.8),
                                emissive: new THREE.Color().setHSL(hue, 0.5, 0.6),
                                emissiveIntensity: 0.4,
                                opacity: 0.8 - layer * 0.2 - j * 0.01,
                                transparent: true,
                                side: THREE.DoubleSide
                            });
                            
                            const feather = new THREE.Mesh(featherGeometry, featherMaterial);
                            feather.position.y = j * 0.15;
                            feather.position.x = j * 0.08 + layer * 0.2;
                            feather.position.z = layer * 0.1;
                            feather.rotation.z = j * 0.03 + layer * 0.1;
                            feather.userData = { 
                                baseRotation: {...feather.rotation},
                                index: j,
                                layer: layer
                            };
                            wingGroup.add(feather);
                        }
                    }
                    
                    // Position wings
                    const angle = pair * (Math.PI * 2 / 3) + side * Math.PI;
                    const radius = 2.5 + pair * 0.3;
                    
                    wingGroup.position.x = Math.cos(angle) * radius;
                    wingGroup.position.z = Math.sin(angle) * radius;
                    wingGroup.position.y = pair * 0.5 - 0.5;
                    wingGroup.rotation.y = angle + Math.PI / 2;
                    
                    if (side === 1) {
                        wingGroup.scale.x = -1;
                    }
                    
                    wingGroup.userData = { 
                        pair: pair,
                        side: side,
                        phase: angle,
                        flapSpeed: 0.5 + pair * 0.2
                    };
                    
                    wings.push(wingGroup);
                    wingSystem.add(wingGroup);
                }
            }
            
            scene.add(wingSystem);
            
            // Sacred Geometry Particles - More complex
            const particleSystems = [];
            const systemCount = 3;
            
            for (let sys = 0; sys < systemCount; sys++) {
                const particleCount = 500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                const systemRadius = 10 + sys * 5;
                const systemType = ['sphere', 'torus', 'spiral'][sys];
                
                for (let i = 0; i < particleCount; i++) {
                    let x, y, z;
                    
                    if (systemType === 'sphere') {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const r = systemRadius + (Math.random() - 0.5) * 2;
                        
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else if (systemType === 'torus') {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI * 2;
                        const r1 = systemRadius;
                        const r2 = 3;
                        
                        x = (r1 + r2 * Math.cos(phi)) * Math.cos(theta);
                        y = r2 * Math.sin(phi);
                        z = (r1 + r2 * Math.cos(phi)) * Math.sin(theta);
                    } else {
                        const t = i / particleCount * Math.PI * 6;
                        const r = systemRadius * (1 - i / particleCount);
                        
                        x = r * Math.cos(t);
                        y = (i / particleCount - 0.5) * 20;
                        z = r * Math.sin(t);
                    }
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    
                    const color = new THREE.Color().setHSL(
                        0.5 + sys * 0.1 + (i / particleCount) * 0.1, 
                        0.8, 
                        0.6
                    );
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = Math.random() * 0.1 + 0.05;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const particles = new THREE.Points(geometry, material);
                particles.userData = { 
                    systemType: systemType,
                    rotationSpeed: 0.02 + sys * 0.01,
                    phase: sys * Math.PI / 3
                };
                
                particleSystems.push(particles);
                scene.add(particles);
            }
            
            // Energy ribbons - More sophisticated
            const ribbonSystem = new THREE.Group();
            const ribbons = [];
            const ribbonCount = 8;
            
            for (let i = 0; i < ribbonCount; i++) {
                const ribbonGroup = new THREE.Group();
                const ribbonSegments = 100;
                const ribbonLayers = 3;
                
                for (let layer = 0; layer < ribbonLayers; layer++) {
                    const points = [];
                    
                    for (let j = 0; j < ribbonSegments; j++) {
                        const t = j / ribbonSegments;
                        const angle = t * Math.PI * 4 + (i / ribbonCount) * Math.PI * 2;
                        const radius = 3 + Math.sin(t * Math.PI * 3) * 2 + layer * 0.5;
                        const height = (t - 0.5) * 10;
                        
                        // Add more complex motion
                        const spiral = t * Math.PI * 2;
                        const wobble = Math.sin(spiral * 3) * 0.5;
                        
                        points.push(new THREE.Vector3(
                            Math.cos(angle) * radius + Math.cos(spiral) * wobble,
                            height + Math.sin(spiral * 2) * wobble,
                            Math.sin(angle) * radius + Math.sin(spiral) * wobble
                        ));
                    }
                    
                    const curve = new THREE.CatmullRomCurve3(points);
                    const tubeGeometry = new THREE.TubeGeometry(
                        curve, 
                        200, 
                        0.05 + layer * 0.02, 
                        8, 
                        false
                    );
                    
                    const hue = (i / ribbonCount) + layer * 0.05;
                    const tubeMaterial = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(hue, 0.7, 0.6),
                        emissive: new THREE.Color().setHSL(hue, 0.8, 0.4),
                        emissiveIntensity: 0.4,
                        opacity: 0.5 - layer * 0.1,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    
                    const ribbon = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    ribbon.userData = { 
                        curve: curve,
                        originalPoints: points,
                        layer: layer
                    };
                    
                    ribbonGroup.add(ribbon);
                }
                
                ribbonGroup.userData = {
                    phase: (i / ribbonCount) * Math.PI * 2,
                    frequency: 1 + i * 0.2,
                    amplitude: 1
                };
                
                ribbons.push(ribbonGroup);
                ribbonSystem.add(ribbonGroup);
            }
            
            scene.add(ribbonSystem);
            
            // Camera setup
            camera.position.set(0, 5, 15);
            
            // State management system
            const states = {
                dormant: {
                    name: 'Dormant',
                    coreScale: 0.8,
                    wheelSpeed: 0.05,
                    wingMovement: 0.1,
                    particleSpeed: 0.01,
                    ribbonAmplitude: 0.5,
                    lightIntensity: 0.3,
                    fogDensity: 0.02
                },
                awakening: {
                    name: 'Awakening',
                    coreScale: 1.0,
                    wheelSpeed: 0.2,
                    wingMovement: 0.3,
                    particleSpeed: 0.02,
                    ribbonAmplitude: 0.8,
                    lightIntensity: 0.5,
                    fogDensity: 0.015
                },
                contemplation: {
                    name: 'Contemplation',
                    coreScale: 1.1,
                    wheelSpeed: 0.3,
                    wingMovement: 0.2,
                    particleSpeed: 0.03,
                    ribbonAmplitude: 1.0,
                    lightIntensity: 0.6,
                    fogDensity: 0.01
                },
                revelation: {
                    name: 'Revelation',
                    coreScale: 1.5,
                    wheelSpeed: 1.0,
                    wingMovement: 1.0,
                    particleSpeed: 0.1,
                    ribbonAmplitude: 2.0,
                    lightIntensity: 1.0,
                    fogDensity: 0.005
                },
                transcendence: {
                    name: 'Transcendence',
                    coreScale: 2.0,
                    wheelSpeed: 2.0,
                    wingMovement: 1.5,
                    particleSpeed: 0.2,
                    ribbonAmplitude: 3.0,
                    lightIntensity: 1.5,
                    fogDensity: 0
                },
                void: {
                    name: 'Void',
                    coreScale: 0.5,
                    wheelSpeed: -0.1,
                    wingMovement: 0.05,
                    particleSpeed: -0.01,
                    ribbonAmplitude: 0.2,
                    lightIntensity: 0.1,
                    fogDensity: 0.05
                }
            };
            
            let currentState = states.dormant;
            let targetState = states.dormant;
            let stateTransition = 1;
            let stateSequence = [];
            let sequenceIndex = 0;
            let sequenceTimer = 0;
            
            // State indicator
            const stateIndicator = document.getElementById('stateIndicator');
            
            // Sacred verses
            const sacredVerses = {
                grief: [
                    { text: "BLESSED ARE THOSE WHO MOURN", ref: "Matthew 5:4" },
                    { text: "THE LORD IS NEAR TO THE BROKENHEARTED", ref: "Psalm 34:18" },
                    { text: "HE HEALS THE BROKENHEARTED", ref: "Psalm 147:3" }
                ],
                freedom: [
                    { text: "YOU WILL KNOW THE TRUTH AND THE TRUTH WILL SET YOU FREE", ref: "John 8:32" },
                    { text: "WHERE THE SPIRIT OF THE LORD IS THERE IS FREEDOM", ref: "2 Corinthians 3:17" },
                    { text: "THE LORD SETS PRISONERS FREE", ref: "Psalm 146:7" }
                ],
                love: [
                    { text: "LOVE ONE ANOTHER AS I HAVE LOVED YOU", ref: "John 15:12" },
                    { text: "GOD IS LOVE", ref: "1 John 4:8" },
                    { text: "YOUR LOVE IS BETTER THAN LIFE", ref: "Psalm 63:3" }
                ],
                fear: [
                    { text: "DO NOT BE AFRAID I AM WITH YOU", ref: "Isaiah 41:10" },
                    { text: "PERFECT LOVE CASTS OUT FEAR", ref: "1 John 4:18" },
                    { text: "THE LORD IS MY LIGHT AND MY SALVATION", ref: "Psalm 27:1" }
                ],
                hope: [
                    { text: "I AM THE RESURRECTION AND THE LIFE", ref: "John 11:25" },
                    { text: "MY HOPE IS IN YOU", ref: "Psalm 39:7" },
                    { text: "THOSE WHO HOPE IN THE LORD WILL RENEW THEIR STRENGTH", ref: "Isaiah 40:31" }
                ],
                wisdom: [
                    { text: "I AM THE WAY THE TRUTH AND THE LIFE", ref: "John 14:6" },
                    { text: "THE FEAR OF THE LORD IS THE BEGINNING OF WISDOM", ref: "Psalm 111:10" },
                    { text: "ASK AND IT WILL BE GIVEN TO YOU", ref: "Matthew 7:7" }
                ],
                truth: [
                    { text: "I AM THE LIGHT OF THE WORLD", ref: "John 8:12" },
                    { text: "YOUR WORD IS TRUTH", ref: "John 17:17" },
                    { text: "SEND OUT YOUR LIGHT AND YOUR TRUTH", ref: "Psalm 43:3" }
                ],
                peace: [
                    { text: "PEACE I LEAVE WITH YOU", ref: "John 14:27" },
                    { text: "BE STILL AND KNOW THAT I AM GOD", ref: "Psalm 46:10" },
                    { text: "BLESSED ARE THE PEACEMAKERS", ref: "Matthew 5:9" }
                ],
                light: [
                    { text: "LET YOUR LIGHT SHINE BEFORE OTHERS", ref: "Matthew 5:16" },
                    { text: "THE LORD IS MY LIGHT", ref: "Psalm 27:1" },
                    { text: "IN HIM WAS LIFE AND THAT LIFE WAS THE LIGHT", ref: "John 1:4" }
                ],
                faith: [
                    { text: "YOUR FAITH HAS MADE YOU WHOLE", ref: "Matthew 9:22" },
                    { text: "WITH GOD ALL THINGS ARE POSSIBLE", ref: "Matthew 19:26" },
                    { text: "THE RIGHTEOUS WILL LIVE BY FAITH", ref: "Romans 1:17" }
                ],
                mercy: [
                    { text: "BLESSED ARE THE MERCIFUL", ref: "Matthew 5:7" },
                    { text: "HIS MERCY ENDURES FOREVER", ref: "Psalm 136:1" },
                    { text: "BE MERCIFUL AS YOUR FATHER IS MERCIFUL", ref: "Luke 6:36" }
                ],
                strength: [
                    { text: "I CAN DO ALL THINGS THROUGH CHRIST", ref: "Philippians 4:13" },
                    { text: "THE LORD IS MY STRENGTH AND MY SHIELD", ref: "Psalm 28:7" },
                    { text: "MY GRACE IS SUFFICIENT FOR YOU", ref: "2 Corinthians 12:9" }
                ]
            };
            
            // Complex emotive mappings with state sequences
            const emotiveMap = {
                grief: {
                    states: ['void', 'dormant', 'contemplation'],
                    colors: { core: 0x1e3a8a, glow: 0x3b82f6, wheels: 0x60a5fa },
                    duration: 3000
                },
                freedom: {
                    states: ['awakening', 'revelation', 'transcendence'],
                    colors: { core: 0xffffff, glow: 0xffd700, wheels: 0xffed4a },
                    duration: 4000
                },
                love: {
                    states: ['awakening', 'revelation'],
                    colors: { core: 0xff1493, glow: 0xff69b4, wheels: 0xffb6c1 },
                    duration: 3500
                },
                fear: {
                    states: ['void', 'dormant', 'void', 'awakening'],
                    colors: { core: 0x8b0000, glow: 0xdc143c, wheels: 0xff6347 },
                    duration: 2000
                },
                hope: {
                    states: ['dormant', 'awakening', 'contemplation'],
                    colors: { core: 0x10b981, glow: 0x34d399, wheels: 0x6ee7b7 },
                    duration: 3500
                },
                wisdom: {
                    states: ['contemplation', 'revelation', 'contemplation'],
                    colors: { core: 0x6b46c1, glow: 0x9333ea, wheels: 0xa78bfa },
                    duration: 4000
                },
                truth: {
                    states: ['void', 'awakening', 'revelation', 'transcendence'],
                    colors: { core: 0xfbbf24, glow: 0xfde047, wheels: 0xfef3c7 },
                    duration: 5000
                },
                peace: {
                    states: ['dormant', 'contemplation'],
                    colors: { core: 0x0ea5e9, glow: 0x38bdf8, wheels: 0x7dd3fc },
                    duration: 4000
                },
                // Special sequences
                enlightenment: {
                    states: ['void', 'dormant', 'awakening', 'contemplation', 'revelation', 'transcendence'],
                    colors: { core: 0xffffff, glow: 0xffffff, wheels: 0xffffff },
                    duration: 8000
                },
                rebirth: {
                    states: ['transcendence', 'void', 'dormant', 'awakening', 'revelation'],
                    colors: { core: 0x00ff00, glow: 0x40ff40, wheels: 0x80ff80 },
                    duration: 6000
                }
            };
            
            // Color interpolation system
            let currentColors = {
                core: new THREE.Color(0xffa500),
                glow: new THREE.Color(0xffa500),
                wheels: new THREE.Color(0xff6b6b),
                wings: new THREE.Color(0x87ceeb),
                particles: new THREE.Color(0x9370db)
            };
            
            let targetColors = {...currentColors};
            
            // Input handling
            const promptInput = document.getElementById('prompt');
            const revelation = document.getElementById('revelation');
            
            promptInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = e.target.value.toLowerCase().trim();
                    processQuery(query);
                    e.target.value = '';
                }
            });
            
            function processQuery(query) {
                let matched = false;
                
                // Check for emotive mappings
                for (const [key, value] of Object.entries(emotiveMap)) {
                    if (query.includes(key)) {
                        initiateStateSequence(value.states, value.duration);
                        
                        targetColors.core = new THREE.Color(value.colors.core);
                        targetColors.glow = new THREE.Color(value.colors.glow);
                        targetColors.wheels = new THREE.Color(value.colors.wheels);
                        targetColors.wings = new THREE.Color(value.colors.wheels).lerp(new THREE.Color(0xffffff), 0.3);
                        targetColors.particles = new THREE.Color(value.colors.glow).lerp(new THREE.Color(value.colors.core), 0.5);
                        
                        matched = true;
                        
                        // Show verse if available
                        if (sacredVerses[key]) {
                            const verses = sacredVerses[key];
                            const selectedVerse = verses[Math.floor(Math.random() * verses.length)];
                            showVerse(selectedVerse);
                        }
                        
                        // Show revelation for transcendent states
                        if (value.states.includes('transcendence') || value.states.includes('revelation')) {
                            setTimeout(() => showRevelation(key.toUpperCase()), value.duration / 2);
                        }
                        
                        break;
                    }
                }
                
                // Special commands
                if (query === 'void') {
                    targetState = states.void;
                    stateTransition = 0;
                } else if (query === 'awaken') {
                    initiateStateSequence(['dormant', 'awakening', 'contemplation'], 3000);
                } else if (query === 'transcend') {
                    initiateStateSequence(['contemplation', 'revelation', 'transcendence'], 5000);
                } else if (query === 'reset') {
                    targetState = states.dormant;
                    stateTransition = 0;
                }
                
                if (!matched && !['void', 'awaken', 'transcend', 'reset'].includes(query)) {
                    // Default contemplation state
                    initiateStateSequence(['awakening', 'contemplation'], 2000);
                    
                    // Show wisdom verse
                    const wisdomVerses = sacredVerses.wisdom;
                    const selectedVerse = wisdomVerses[Math.floor(Math.random() * wisdomVerses.length)];
                    showVerse(selectedVerse);
                }
            }
            
            function initiateStateSequence(stateNames, duration) {
                stateSequence = stateNames.map(name => states[name]);
                sequenceIndex = 0;
                sequenceTimer = 0;
                targetState = stateSequence[0];
                stateTransition = 0;
                
                // Calculate time per state
                stateSequence.forEach(state => {
                    state.duration = duration / stateSequence.length;
                });
            }
            
            function showRevelation(text) {
                revelation.textContent = text;
                revelation.classList.add('visible');
                setTimeout(() => {
                    revelation.classList.remove('visible');
                }, 4000);
            }
            
            function showVerse(verse) {
                const verseElement = document.getElementById('verse');
                const verseText = verseElement.querySelector('.verse-text');
                const verseRef = verseElement.querySelector('.verse-ref');
                
                verseText.textContent = verse.text;
                verseRef.textContent = verse.ref;
                
                verseElement.classList.add('visible');
                setTimeout(() => {
                    verseElement.classList.remove('visible');
                }, 6000);
            }
            
            // Helper function for smooth interpolation
            function lerp(a, b, t) {
                return a + (b - a) * t;
            }
            
            // Custom cursor
            const cursor = document.querySelector('.custom-cursor');
            document.addEventListener('mousemove', (e) => {
                cursor.style.left = e.clientX - 10 + 'px';
                cursor.style.top = e.clientY - 10 + 'px';
            });
            
            // Animation loop
            const clock = new THREE.Clock();
            let deltaTime = 0;
            
            function animate() {
                requestAnimationFrame(animate);
                
                deltaTime = clock.getDelta();
                const elapsedTime = clock.getElapsedTime();
                
                // Handle state sequences
                if (stateSequence.length > 0) {
                    sequenceTimer += deltaTime * 1000;
                    
                    if (sequenceTimer > targetState.duration && sequenceIndex < stateSequence.length - 1) {
                        sequenceIndex++;
                        targetState = stateSequence[sequenceIndex];
                        stateTransition = 0;
                        sequenceTimer = 0;
                    } else if (sequenceTimer > targetState.duration && sequenceIndex >= stateSequence.length - 1) {
                        stateSequence = [];
                        sequenceIndex = 0;
                        sequenceTimer = 0;
                    }
                }
                
                // State transitions
                stateTransition = Math.min(stateTransition + deltaTime * 0.5, 1);
                
                // Interpolate all state values
                currentState = {
                    name: targetState.name,
                    coreScale: lerp(currentState.coreScale, targetState.coreScale, stateTransition),
                    wheelSpeed: lerp(currentState.wheelSpeed, targetState.wheelSpeed, stateTransition),
                    wingMovement: lerp(currentState.wingMovement, targetState.wingMovement, stateTransition),
                    particleSpeed: lerp(currentState.particleSpeed, targetState.particleSpeed, stateTransition),
                    ribbonAmplitude: lerp(currentState.ribbonAmplitude, targetState.ribbonAmplitude, stateTransition),
                    lightIntensity: lerp(currentState.lightIntensity, targetState.lightIntensity, stateTransition),
                    fogDensity: lerp(currentState.fogDensity, targetState.fogDensity, stateTransition)
                };
                
                // Update state indicator
                stateIndicator.textContent = currentState.name;
                stateIndicator.style.opacity = 0.3 + currentState.lightIntensity * 0.3;
                
                // Update fog
                scene.fog.near = 1;
                scene.fog.far = 50 / (1 + currentState.fogDensity * 10);
                
                // Animate core group
                coreGroup.scale.setScalar(currentState.coreScale);
                coreGroup.rotation.y += deltaTime * 0.1 * currentState.wheelSpeed;
                
                // Pulse effect
                const breathe = 1 + Math.sin(elapsedTime * currentState.wheelSpeed * 2) * 0.1;
                innerCore.scale.setScalar(breathe);
                
                // Animate crystal layers
                crystalLayers.forEach((crystal, i) => {
                    const speed = crystal.userData.rotationSpeed * currentState.wheelSpeed;
                    crystal.rotation.x += deltaTime * speed;
                    crystal.rotation.y += deltaTime * speed * 1.3;
                    crystal.rotation.z += deltaTime * speed * 0.7;
                    
                    // State-based visibility
                    crystal.material.opacity = 0.3 - i * 0.1 + currentState.lightIntensity * 0.2;
                });
                
                // Update core colors
                innerCoreMaterial.emissive.lerp(currentColors.core, 0.02);
                outerCoreMaterial.uniforms.glowColor.value.lerp(currentColors.glow, 0.02);
                outerCoreMaterial.uniforms.time.value = elapsedTime;
                outerCoreMaterial.uniforms.pulse.value = currentState.wheelSpeed * 2;
                
                // Color interpolation
                for (const key in currentColors) {
                    currentColors[key].lerp(targetColors[key], 0.02);
                }
                
                // Animate wheel system
                wheelSystem.rotation.y += deltaTime * currentState.wheelSpeed * 0.05;
                
                wheels.forEach((wheelGroup, i) => {
                    const userData = wheelGroup.userData;
                    const speed = userData.rotationSpeed * currentState.wheelSpeed;
                    
                    // Smooth rotation using sine waves for organic motion
                    const smoothingFactor = currentState.name === 'Transcendence' ? 0.7 : 1.0;
                    const timeOffset = elapsedTime + userData.phase;
                    
                    // Complex rotation on multiple axes with smoothing
                    wheelGroup.rotation.x += deltaTime * speed * smoothingFactor;
                    wheelGroup.rotation.y += deltaTime * speed * 0.7 * smoothingFactor;
                    wheelGroup.rotation.z += deltaTime * speed * 0.3 * smoothingFactor;
                    
                    // Smooth orbital motion using sine/cosine
                    const orbitSpeed = userData.orbitSpeed * currentState.wheelSpeed;
                    const orbitAngle = timeOffset * orbitSpeed;
                    const orbitRadius = 2 + Math.sin(timeOffset * 0.2) * 0.5; // Gentle radius variation
                    
                    wheelGroup.position.x = Math.cos(orbitAngle) * orbitRadius;
                    wheelGroup.position.z = Math.sin(orbitAngle) * orbitRadius;
                    wheelGroup.position.y = Math.sin(timeOffset * 0.3) * 0.5; // Gentle vertical motion
                    
                    // Update wheel materials
                    const wheelMesh = wheelGroup.children[0];
                    if (wheelMesh.material.uniforms) {
                        wheelMesh.material.uniforms.time.value = elapsedTime;
                        wheelMesh.material.uniforms.color1.value.lerp(currentColors.wheels, 0.02);
                        wheelMesh.material.uniforms.color2.value.lerp(currentColors.glow, 0.02);
                        wheelMesh.material.uniforms.opacity.value = 0.6 + currentState.lightIntensity * 0.2;
                    }
                    
                    // Animate eyes on wheels with smooth motion
                    wheelGroup.children.forEach((child, j) => {
                        if (child.userData && child.userData.angle !== undefined) {
                            const eyeData = child.userData;
                            const eyePulse = Math.sin(elapsedTime * 3 + eyeData.phase) * 0.3 + 0.7;
                            child.scale.setScalar(eyePulse * currentState.lightIntensity);
                            
                            // Smooth spiral motion for eyes in Transcendence
                            if (currentState.name === 'Transcendence') {
                                const spiralSpeed = 0.3; // Reduced from 0.5
                                const spiralOffset = elapsedTime * spiralSpeed;
                                const radiusVariation = 1 + Math.sin(elapsedTime * 0.5 + j * 0.1) * 0.1;
                                
                                child.position.x = Math.cos(eyeData.angle + spiralOffset) * eyeData.radius * radiusVariation;
                                child.position.z = Math.sin(eyeData.angle + spiralOffset) * eyeData.radius * radiusVariation;
                                child.position.y += Math.sin(elapsedTime * 2 + j * 0.1) * 0.01; // Reduced amplitude
                            }
                        }
                    });
                });
                
                // Animate wings with complex motion
                wings.forEach((wingGroup, i) => {
                    const userData = wingGroup.userData;
                    const flapSpeed = userData.flapSpeed * currentState.wingMovement;
                    
                    // Base flapping motion
                    const flapAngle = Math.sin(elapsedTime * flapSpeed + userData.phase) * 0.3;
                    wingGroup.rotation.z = flapAngle * (userData.side === 0 ? 1 : -1);
                    
                    // Vertical movement
                    wingGroup.position.y = userData.pair * 0.5 - 0.5 + 
                        Math.sin(elapsedTime * flapSpeed * 0.5 + userData.phase) * 0.5 * currentState.wingMovement;
                    
                    // State-specific behaviors
                    if (currentState.name === 'Revelation' || currentState.name === 'Transcendence') {
                        // Dramatic wing spread
                        wingGroup.rotation.x = Math.sin(elapsedTime * 2 + userData.phase) * 0.2;
                        wingGroup.scale.y = 1 + Math.sin(elapsedTime * 3) * 0.2;
                    } else if (currentState.name === 'Void') {
                        // Wings fold inward
                        wingGroup.rotation.y = userData.phase + Math.PI / 2 + 
                            (userData.side === 0 ? 0.5 : -0.5) * currentState.wingMovement;
                    }
                    
                    // Animate individual feathers
                    wingGroup.children.forEach((feather, j) => {
                        if (feather.userData) {
                            const featherData = feather.userData;
                            const wave = Math.sin(elapsedTime * flapSpeed * 2 + 
                                featherData.index * 0.1 + featherData.layer * 0.5) * 0.05;
                            
                            feather.rotation.z = featherData.baseRotation.z + wave * currentState.wingMovement;
                            feather.material.emissiveIntensity = 0.4 + 
                                Math.sin(elapsedTime * 3 + featherData.index * 0.1) * 0.2 * currentState.lightIntensity;
                            
                            // Update wing colors
                            feather.material.emissive.lerp(currentColors.wings, 0.02);
                        }
                    });
                });
                
                // Animate particle systems
                particleSystems.forEach((particles, i) => {
                    const userData = particles.userData;
                    
                    particles.rotation.y += deltaTime * userData.rotationSpeed * currentState.particleSpeed;
                    particles.rotation.x += deltaTime * userData.rotationSpeed * 0.5 * currentState.particleSpeed;
                    
                    // Expand/contract based on state
                    const scale = 1 + (currentState.coreScale - 1) * 0.5;
                    particles.scale.setScalar(scale);
                    
                    // Update particle colors and opacity
                    particles.material.opacity = 0.3 + currentState.lightIntensity * 0.3;
                    particles.material.size = 0.05 + currentState.lightIntensity * 0.05;
                    
                    // Special effects for different states
                    if (currentState.name === 'Transcendence') {
                        // Particles spiral outward
                        const positions = particles.geometry.attributes.position.array;
                        for (let j = 0; j < positions.length; j += 3) {
                            const radius = Math.sqrt(positions[j] * positions[j] + 
                                                   positions[j + 2] * positions[j + 2]);
                            positions[j] *= 1 + deltaTime * 0.1;
                            positions[j + 2] *= 1 + deltaTime * 0.1;
                            
                            if (radius > 30) {
                                // Reset particles that go too far
                                positions[j] *= 0.3;
                                positions[j + 2] *= 0.3;
                            }
                        }
                        particles.geometry.attributes.position.needsUpdate = true;
                    }
                });
                
                // Animate ribbons with state-based behavior
                ribbons.forEach((ribbonGroup, i) => {
                    const groupData = ribbonGroup.userData;
                    const phase = groupData.phase + elapsedTime * 0.3 * currentState.ribbonAmplitude;
                    
                    ribbonGroup.children.forEach((ribbon, layer) => {
                        const ribbonData = ribbon.userData;
                        const points = [];
                        
                        ribbonData.originalPoints.forEach((point, j) => {
                            const t = j / ribbonData.originalPoints.length;
                            
                            // Complex wave motion
                            const wave1 = Math.sin(phase + t * Math.PI * 4) * currentState.ribbonAmplitude;
                            const wave2 = Math.cos(phase * 0.7 + t * Math.PI * 6) * currentState.ribbonAmplitude * 0.5;
                            const wave3 = Math.sin(phase * 1.3 + t * Math.PI * 2) * currentState.ribbonAmplitude * 0.3;
                            
                            const wobble = wave1 + wave2 + wave3;
                            
                            // State-specific deformations
                            let stateModifier = 1;
                            if (currentState.name === 'Void') {
                                stateModifier = 0.3 + t * 0.7; // Ribbons collapse toward center
                            } else if (currentState.name === 'Transcendence') {
                                stateModifier = 1 + Math.sin(t * Math.PI) * 2; // Ribbons expand dramatically
                            }
                            
                            points.push(new THREE.Vector3(
                                point.x * stateModifier + Math.cos(phase + t * Math.PI * 2) * wobble * 0.5,
                                point.y + Math.sin(phase + t * Math.PI * 3) * wobble * 0.3,
                                point.z * stateModifier + Math.sin(phase + t * Math.PI * 2) * wobble * 0.5
                            ));
                        });
                        
                        //const newCurve = new THREE.CatmullRomCurve3(points);
                        //ribbon.geometry.dispose();
                        //ribbon.geometry = new THREE.TubeGeometry(newCurve, 200, 0.05 + layer * 0.02, 8, false);
                        
                        // Update ribbon appearance
                        ribbon.material.opacity = (0.5 - layer * 0.1) * currentState.lightIntensity;
                        ribbon.material.emissiveIntensity = 0.4 * currentState.lightIntensity;
                        ribbon.material.emissive.lerp(currentColors.glow, 0.02);
                    });
                    
                    // Rotate entire ribbon group
                    ribbonGroup.rotation.y += deltaTime * 0.1 * currentState.wheelSpeed;
                });
                
                // Update dynamic lights
                lights.forEach((light, i) => {
                    const angle = elapsedTime * 0.2 + (i / lights.length) * Math.PI * 2;
                    const radius = 5 + Math.sin(elapsedTime * 0.5 + i) * 2;
                    
                    light.position.x = Math.cos(angle) * radius;
                    light.position.z = Math.sin(angle) * radius;
                    light.position.y = Math.sin(angle * 2) * 3;
                    
                    light.intensity = currentState.lightIntensity * (0.5 + Math.sin(elapsedTime * 2 + i) * 0.3);
                    light.color.lerp(currentColors.glow, 0.02);
                });
                
                // Camera movement
                const cameraRadius = 15 + Math.sin(elapsedTime * 0.1) * 3 * (2 - currentState.coreScale);
                const cameraSpeed = 0.05 * currentState.wheelSpeed;
                
                camera.position.x = Math.sin(elapsedTime * cameraSpeed) * cameraRadius;
                camera.position.z = Math.cos(elapsedTime * cameraSpeed) * cameraRadius;
                camera.position.y = 5 + Math.sin(elapsedTime * 0.1) * 2 + currentState.coreScale * 2;
                
                camera.lookAt(coreGroup.position);
                
                // Smooth camera shake for intense states
                if (currentState.name === 'Transcendence') {
                    // Use smooth sine waves instead of random shake
                    const shakeIntensity = 0.05 * currentState.wheelSpeed;
                    camera.position.x += Math.sin(elapsedTime * 10) * shakeIntensity;
                    camera.position.y += Math.cos(elapsedTime * 12) * shakeIntensity;
                    camera.position.z += Math.sin(elapsedTime * 8) * shakeIntensity * 0.5;
                } else if (currentState.name === 'Void') {
                    // A smoother, unsettling drift instead of a harsh shake
                    const shakeIntensity = 0.03 * currentState.wheelSpeed;
                    camera.position.x += Math.sin(elapsedTime * 5) * shakeIntensity;
                    camera.position.y += Math.cos(elapsedTime * 6) * shakeIntensity;
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Initialize with dormant state
            currentState = states.dormant;
            setTimeout(() => {
                processQuery('awaken');
            }, 1000);
    
    // --- IMPLEMENTATION FOR INITIAL REVELATION & HIDDEN KEY ---
    
            // Get the new elements from the DOM
            const initialRevelationEl = document.getElementById('initialRevelation');
            const hiddenKeyEl = document.getElementById('hiddenKey');
            const helpScrollEl = document.getElementById('helpScroll');
            const scrollContentEl = document.querySelector('.scroll-content');
            
            // 1. Logic for the Initial Revelation
            function handleInitialRevelation() {
                // Fade in after 2 seconds
                setTimeout(() => {
                    initialRevelationEl.classList.add('visible');
                }, 2000);
            
                // Fade out after 8 seconds
                setTimeout(() => {
                    initialRevelationEl.classList.remove('visible');
                }, 8000);
            }
            
            // 2. Logic for the Hidden Key and Help Scroll
            function setupHelpSystem() {
                const closeButtonEl = document.querySelector('.close-button');
                
                // Add a click listener to the close button
                closeButtonEl.addEventListener('click', () => {
                    helpScrollEl.classList.remove('visible');
                });        
                // Show the help scroll when the key is clicked
                hiddenKeyEl.addEventListener('click', () => {
                    helpScrollEl.classList.add('visible');
                });
            
                // Hide the help scroll when it's clicked
                helpScrollEl.addEventListener('click', () => {
                    helpScrollEl.classList.remove('visible');
                });
            
                // Prevent clicks on the content from closing the scroll
                scrollContentEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            handleInitialRevelation();
            setupHelpSystem();
    </script>
</body>
</html>
